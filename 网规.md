
## 画圆 与 marker 物重叠 如何解决在marker物下面进行穿透依然能在地图上面 画圆、打点、画半径等等

## 画半径与marker 物重叠

## 画多边形 交叉区域如何取交集


## 地图上有很多监听事件诸如click、mousemove、hover等(甚至绘制的多边形、marker), 事件的监听是否有进行移除 如何件监听内存泄漏并进行释放


## 热力图性能优化

在高德地图 2.0 API 中做热力图（HeatMapLayer），你遇到的问题其实是 数据量大，渲染和交互卡顿。这个场景非常常见（比如订单分布、外卖量、客流量分析）。优化思路可以从 前端渲染层面 和 后端数据处理层面 两方面入手：

🔹 前端优化方案

减少点位数量（抽稀/聚合）

如果原始数据几十万甚至上百万点，直接丢进热力图会卡顿。

方案：

#### 数据聚合

采样/抽稀：后端提前做随机抽样，比如取 10%~30%。

聚合：将原始点聚合成“格网数据”，例如把某个 500m × 500m 网格里的订单数统计出来，作为一个点（{lng, lat, count}）。

详细说明: 

核心思想: 把地图划成等大小的小格（cell），把落在同一格的点聚合成一个值（计数/加权和），最后输出每格的中心点 + 强度

```tsx
{ lng, lat, count } // 高德热力图需要的结构
```

> 前端只请求当前视野数据；缩放时变更格网大小；

`相同的网格 计数、加权和`

1. 地图划格子的基本思路

- 假设你设定格子的大小为 500m × 500m（比如一个正方形网格）。
- 整个城市地图就被切成了很多个网格（cell）。
- 每个订单点 (lng, lat) 会根据坐标落到某一个格子里面。

2. 如何计算格子索引（找到属于哪个格子）

- 先确定地图的最小经纬度 (lng_min, lat_min) 作为基准点。
- 对每个点 (lng, lat)：
```tsx
x_index = floor((lng - lng_min) / lng_step)
y_index = floor((lat - lat_min) / lat_step)
```

- lng_step：每格的经度跨度（500m换算成经度差）
- lat_step：每格的纬度跨度（500m换算成纬度差）

这样所有点就能归到某个 (x_index, y_index) 的格子中。

3. 计数（Count）

如果只是看订单量：
- 每个点在格子里，就给该格子的 count +1。
- 最终热力图数据就是 {lng_center, lat_center, count}
    - lng_center, lat_center：格子中心点坐标
    - count：该格子累计的订单数

例如：

- A格子里有 500 个订单 → 输出一个点 {lng: 格子中心, lat: 格子中心, count: 500}

4. 加权和（Weighted Sum）

有时候订单不是“同等重要”，可能要考虑 金额、距离、配送量等。
这种情况：

- 每个点都有一个权重 w（比如订单金额 30 元、50 元）。

- 聚合的时候 不是 count+1，而是 count+w。

公式：

```tsx
GridValue = Σ (w_i)
```

例如：

- A格子里有订单金额 [30, 50, 20]
- 聚合结果：GridValue = 100

这样就能把几十万、几百万个订单点压缩成几千个格子点，大大优化热力图渲染。

#### 

分片加载（分页/分区渲染）

将全国/全市数据按区域拆分，用户在当前地图视野范围时，只加载当前可见区域的数据。

AMap 提供 map.getBounds() 可以拿到当前视野的矩形范围，根据这个范围去后端取数据。

🔑 核心思路

前端：

通过 `map.getBounds()` 获取用户当前地图可见矩形区域（东北角、南西角坐标）。

在地图交互事件 `（moveend、zoomend）`触发时，调用接口请求该矩形区域的数据。

把返回的数据交给热力图渲染。

⚡ 优化点

#### 缓存

同一个区域（bounds）不要重复请求，可以用 Map 缓存。

#### 防抖

地图拖动时不要疯狂请求，最好等 moveend 事件触发。


#### AbortController：避免旧请求覆盖新请求。

1️⃣ 核心原理

AbortController 是浏览器原生 API，用来 中断一个正在进行的 fetch 请求。

每次发请求时：

新建一个 AbortController 实例

把它的 signal 传给 fetch

如果用户再次触发新的请求：

调用之前请求的 controller.abort() → 上一个请求被中断

新请求创建新的 AbortController

这样保证了：旧请求不可能再返回数据并覆盖新数据

#### 动态半径

动态半径：根据 zoom 调整 heatmap 的 radius 参数。

后端：

数据存储时按经纬度存放。

查询时利用 bounds 作为过滤条件，只返回该区域的数据。

如果数据量很大，可以在数据库层做聚合（分桶 / 网格 / 瓦片）。

#### 限制渲染精度

热力图的参数 radius（半径）和 gradient（渐变色）可以影响性能：

较小半径 → 更多点，渲染慢；

较大半径 → 模糊但性能好。

建议根据缩放等级动态调整半径，比如 zoom 越小（看范围大），半径设大一点。

<!-- WebGL 加速

高德 v2.0 的 AMap.HeatMap 底层是 Canvas，如果数据很多会卡顿。

可以考虑 AMap.CustomLayer + WebGL 自己渲染点数据，性能会好很多。

或者直接用 L7（AntV L7 地理可视化库） 结合高德底图，支持 GPU 热力图。 -->

🔹 后端优化方案

数据预聚合

不要把每个订单坐标都传给前端，而是在后端做统计：

以网格（grid）为单位：比如 0.01° × 0.01°，统计落在该格内的订单数。

以行政区为单位：比如街道/区/商圈，统计订单量。

前端只渲染聚合结果，而不是原始点。

分级返回数据

根据缩放层级返回不同粒度的数据：

(网格大小根据 zoom 由后端返回（前端不需要额外处理，只要用 radius 匹配 zoom 即可）。)

zoom < 10 → 返回市级聚合数据  5km × 5km

zoom 10–13 → 返回区级数据    1km × 1km

zoom > 13 → 返回网格数据（更精细）500m × 500m

这样既保证性能，又能给用户“越放大越详细”的体验。

这样：

zoom 小 → 网格大，radius 大 → 点少，热力图整体清晰。

zoom 大 → 网格小，radius 小 → 点多，热力图细节丰富。

✅ 总结：

数据结构：数组 [{lng,lat,count}]，可选 max。

调用方式：

1. heatmap.setDataSet({data, max}) 更新热力图数据。

2. heatmap.setOptions({radius}) 动态调整半径。

3. 聚合网格：后端返回每个网格中心点 + 权重，前端直接渲染即可。

4. zoom 联动：前端 radius + 后端网格粒度联动，实现高性能热力图。

