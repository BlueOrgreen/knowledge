
## 数据源管理器

伪代码

```tsx
// 用 zustand 来维护三个状态：
interface DataSourceState {
  cache: Record<string, any>; // 接口缓存
  pending: Record<string, Promise<any>>; // 正在请求的接口
  queue: Array<() => void>; // 请求队列
  concurrent: number; // 当前并发数
  maxConcurrent: number; // 最大并发数
  fetchData: (key: string, fetcher: () => Promise<any>) => Promise<any>;
}

import create from 'zustand';

export const useDataSourceStore = create<DataSourceState>((set, get) => ({
  cache: {},
  pending: {},
  queue: [],
  concurrent: 0,
  maxConcurrent: 5,

  fetchData: async (key, fetcher) => {
    const { cache, pending, concurrent, maxConcurrent, queue } = get();

    // 1. 如果缓存命中，直接返回
    if (cache[key]) return cache[key];

    // 2. 如果请求已经在进行中，直接返回同一个 promise
    if (pending[key]) return pending[key];

    // 3. 创建请求函数
    const requestFn = () => {
      set(state => ({
        concurrent: state.concurrent + 1,
      }));

      const promise = fetcher()
        .then(res => {
          set(state => {
            state.cache[key] = res;
            delete state.pending[key];
            state.concurrent -= 1;
            return state;
          });

          // 请求完成，触发队列
          const next = get().queue.shift();
          next && next();
          return res;
        })
        .catch(err => {
          set(state => {
            delete state.pending[key];
            state.concurrent -= 1;
            const next = get().queue.shift();
            next && next();
            return state;
          });
          throw err;
        });

      set(state => ({
        pending: { ...state.pending, [key]: promise },
      }));

      return promise;
    };

    // 4. 并发控制
    if (concurrent >= maxConcurrent) {
      // 并发超限，加入队列
      return new Promise((resolve, reject) => {
        get().queue.push(() => {
          requestFn().then(resolve).catch(reject);
        });
      });
    } else {
      // 可直接发起请求
      return requestFn();
    }
  },
}));

```