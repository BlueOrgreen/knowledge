
## 防抖

简单版

```tsx
function debouced(fun, wait) {
    let timeout;

    return function(...args) {
        const context = this // 保存调用时的 this → context

        clearTimeout(timeout)
        timeout = setTimeout(() => {
            func.apply(context, args)
        }, wait)
    }
}
```

#### 立即执行版防抖

有时候我们想要 `先立即执行一次，后续防抖`

```js
function debounce(func, wait, immediate) {
    let timeout;

    return function(...args) {
        const context = this

        const callNow = immediate && !timeout;

        clearTimeout(timeout);
        timeout = setTimeout(() => {
            timeout = null;
            if (!immediate) func.apply(context, args);
        }, wait);

        if (callNow) func.apply(context, args);
    }
}
```

#### func.apply(context, args)

> 确保 func 被调用时，它里面的 this 和参数，跟外面调用时完全一样。

如果没有 apply，在防抖里 func(args) 会这样 丢掉调用的this👇

```js
const input = document.querySelector('input');

function handle(e) {
  console.log(this, e);
}

// ⭐ this 不是由「函数定义」决定的，而是由「函数调用时」的方式决定的。
input.addEventListener('input', handle); 
// this = input ; element 在浏览器调用 handler 的时候会自动绑定：

input.addEventListener('input', debounce(handle, 300)); 
// 如果 debounce 里直接 func(e) 就会丢掉 this → 变成 window

// 在 debounce 里会发生什么？

// 防抖的原理是返回一个「包裹函数」

// input.addEventListener('input', debouncedFn);  当浏览器调用这个「返回的防抖函数」时，this 是 input 没错

// 但是你在里面调用了 func(args);  这里「调用 func」没有任何绑定
func() → 普通调用
// 在非严格模式里 this → window
// 在严格模式里：this → undefined

```

一句话总结:
在防抖里如果不处理 this，调用原始函数时会失去调用者，导致 this 变成 window 或 undefined。用 apply(context, args) 就能保留正确的 this 和参数


#### 防抖与节流

|      | `防抖（debounce）`   | `节流（throttle）`       |
| ---- | -------------- | ------------------ |
| 定义   | 停止触发一段时间后才调用一次 | 固定时间间隔内最多调用一次      |
| 典型场景 | 输入框搜索、表单验证     | scroll、resize、鼠标拖拽 |
| 形象理解 | 拖到最后才算数        | 保证按节奏持续触发          |


#### 防抖函数的箭头函数版本

防抖函数能不能用箭头函数写?
答:  1.防抖本身（外层工厂函数）可以用箭头函数写; 2.但内部返回的 `防抖包裹函数` 最好用普通函数，以正确获得调用时的 `this`

```js
// ✅ 最简洁
// ✅ 适用于「this 不敏感」的场景
// ✅ 比如：调用时不用关心 this 的工具方法
const debounce = (func, wait) => {
  let timeout;
  return (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func(...args);
    }, wait);
  };
};
```

因为 箭头函数本身没有自己的 `this` 所有推荐 `箭头函数外层 + 普通函数返回` 版

```js
const debounce = (func, wait) => {
  let timeout;
  return function (...args) {
    const context = this;
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(context, args);
    }, wait);
  };
};
```

## 节流

`节流（throttle）= 固定时间间隔内最多触发一次`

简单版本

```js
function throttle(func, wait) {
  let lastTime = 0;

  return function(...args) {
    const now = Date.now();

    if(now - lastTime >= wait) {
      lastTime = now();
      func.apply(this, args)
    }
  }
}
```

进阶版本

允许配置
leading: false → 一开始先不触发
trailing: true → 结束后再执行一次

```js
function throttle(func, wait. options = {}) {
  let timeout = null
  let previous = 0

  return function(...args) {
    const context = this
    const now = Date.now()

    if (!previous & options.leading === false) previous = now

    const remaining = wait - (now - previous)

    if(remaining <= 0) {
      clearTimeout(timeout)
      timeout = null;
      previous = now
      func.apply(context, args)
    } else if(!timeout && && options.trailing !== false) {
      timeout = setTimeout(() => {
        previous = options.leading === false ? 0 : Date.now()
        timeout = null
        func.apply(context, args)
      }, remaining)
    }
  }
}
```
