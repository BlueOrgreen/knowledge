# 前端工程化/网络面试题

## 一. 接口超时请求

> 你们的接口超时时间一般设多少？
> 为什么要做超时控制？你会怎么做？

✅ 前端接口超时一般设在 `5-10s` 中

- 大部分业务场景：5–10 秒
- 重要慢接口（比如需要汇总数据）：10–15 秒
- 极端情况（大文件上传、超大搜索）：>30 秒也可能，但要明确给用户提示

✅ 设计超时的核心原则

1. 保证用户体验

- 人在等待时感知 2 秒以内是「很快」
- 超过 5–10 秒用户就会怀疑是不是卡死了
- 所以前端要能给出「超时提示」

2. 避免资源浪费

- 网络请求挂起时间过长占用连接
- 可能导致浏览器并发数耗尽

3. 和后端约定

- 后端一般也有超时
- 前后端要「对齐」这个阈值

> 参考回到, 我一般会给前端请求加超市, 一般业务场景都在 5- 10 秒内, 避免后端或者网络异常时用户一直转圈. 超时后会提示用户重试或降级内容. 对于特殊慢接口也会放宽到15s甚至更多, 但是都会做loading、错误提示、避免用户卡住


| 场景类型      | 建议超时            |
| --------- | --------------- |
| 一般API接口   | 5–10 秒          |
| 慢查询/复杂聚合  | 10–15 秒         |
| 大文件上传下载   | 30 秒以上（用户可感知进度） |
| 心跳 / 轮询接口 | < 5 秒一次，但每次超时短  |



## 二、 前端稳定性保障设计

> 你们前端怎么做稳定性？
> 有没有做过可用性保障的设计？
> 线上出过问题怎么排查？


### 前端「稳定性保障」核心思路

稳定性设计的本质是：

⭐「就算后端挂了、网络慢了、代码出错了，用户也不能卡死或白屏。」
⭐「就算出错，也能快速发现、定位、恢复。」

所以要覆盖三个层面：

1. 预防（减少线上出错概率）
2. 降级（出错了还能用）
3. 监控（出错了能知道）


#### 1.预防型设计

⭐ 目标：上线前就减少 bug

- TS类型检查
- ESLint 代码规范 统一团队代码风格 避免潜在BUG
- 关键逻辑、复杂逻辑有单元测试覆盖
- 写防御性代码(代码参数判空处理)

## 如何让用户回到浏览器上次阅读的位置


## 前端如何实现截图

> https://www.bilibili.com/video/BV1BzMFzNEvg/?spm_id_from=333.788.recommend_more_video.1&vd_source=9089a61868d44cb9cf4fbec022221170

考察能力：
1.对浏览器的认知
2.对相关技术方案的了解
    - 基于DOM渲染到 `Canvas`
    - 基于浏览器原生API `getDisplayMedia`
3.原理的深入了解
4.优缺点分析与适用场景
5.安全性和用户隐私意识


### 方案一

基于DOM元素渲染到 `Canvas`

1. DOM 解析遍历
2. 样式计算（弄清里面的文字字号、文字颜色、背景图、边框多粗等）
3. 内容绘制（在内存中创建`canvas`元素，将解析到的DOM结构和样式信息,模拟浏览器渲染引擎的行为将元素逐个绘制道`canvas`上）
5. 图片导出（画完的canvas即是我们想要的截图内容，用canvas自带的 `toDataURL` 或者导出 `prolog` 方法，就能将这张画导出成真正的图片文件）

优缺点分析

- 优点:
    - 纯前端实现
    - 可以精确的控制截取页面中的特定DOM元素

- 缺点:
    - 非真实像素级截图（即它是临摹出来的，所以一些复杂CSS特效、特殊的字体，它可能画不出来）
    - 性能开销较大（如果截图的内容较多，可能等待时长会久一些）
    - 动态内容无法支持（像git图或者视频只能截取到按快门的那一瞬）


### 方案二

基于浏览器原生API `getDisplayMedia`； 这个API是专门用来做屏幕共享和视频录制的

1. 用户授权： 调用`navigator.mediaDevices.getDisplayMedia` （代码调用后浏览器会询问是否用户授权同意）
2. 获取视频流：接口会给予我们 `MediaStream` 
3. 将流渲染到 `videa` 标签中， `video` 会播放实时画面
4. 从 `video` 截取当前帧到 `canvas`
5. 图片导出 （用canvas的 `toDataURL` 或者 `toblock` 把截图内容转化成图片）
6. 停止捕获（调用视频流轨道上的 `stop`）

优缺点：

优点
- 真实像素级截图
- 可以截取浏览器外部的内容
- 可以捕获包括CSS复杂渲染、插件内容等在内的所有可见内容

缺点
- 用户授权
- 异步操作
- 无法精准控制截取特定DOM元素
- 浏览器兼容性

## 三、 前端如何实现文件预览

1. 适用 `iframe` 原生预览 `pdf`
2. 使用 `mammoth.js` 库预览 `word` 文件
3. 使用微软 `office online` 服务预览 `.xlsx` `excel` 文件


```ts
// 使用微软 office online 服务预览 excel 文件
function previewXlsx() {
    // 1. 将文件 URL 进行编码
    const encodedUrl = encodeURIComponent(XLSX_URL)
    // 2. 构造微软预览服务的URL
    const microsoftPreviewUrl = `https://view.officeapps.live.com/op/view.aspx?src=${encodedUrl}`

    // 3.将构造好的URL放入 iframe
    <iframe src ={microsoftPreviewUrl} >
}
```
